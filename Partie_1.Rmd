---
title: "Mon Document"
output: word_document
always_allow_html: true
---



## Chargement des donn√©es.
```{r}
library(readxl)
donnees <- read_excel("RES_all_cleaned.xlsx")
```

## Q2.1
L'objectif de cette question est de d√©terminer quelle valeur statistique est la plus repr√©sentive pour caract√©riser la performance d'un enfant √† partir de ses 5 essais.

##-- Hypoth√®ses possible pour la s√©lection des valeurs 
###--- Moyenne des 5 essais
Elle repr√©sente l'ensemble des performances sur les 5 essais et r√©duit l'influence des variations al√©atoires entre essais. Cependant elle est sensible aux valeurs extr√™mes.

###--- M√©diane des 5 essais
La m√©diane est plus robuste face aux valeurs extr√™mes. Par contre elle ne prend pas compte toutes les donn√©es, seulement la valeur centrale.


Dans cette √©tude, nous privil√©gions donc la m√©diane, car elle est plus robuste et offre une meilleure estimation de la tendance centrale sans √™tre affect√©e par des erreurs de mesure ou des performances exceptionnelles dans certains essais.

## Q2.2
## D√©tection des valeurs manquantes
```{r}

# V√©rifier les valeurs manquantes
missing_values <- colSums(is.na(donnees))

# Afficher les colonnes contenant des valeurs manquantes
missing_values[missing_values > 0]

```


## Identification des valeurs aberrantes


```{r}
# D√©finition des groupes de variables
time_vars <- c("TAju(ms)", "TExe(ms)", "TPas(ms)", "TLoad(ms)", "TUnload(ms)")

cop_vars <- c("CoP_tot_AP(/Long)", "CoP_tot_ML(/Larg)", "CoP_loadAP(/Long)", 
              "CoP_load_ML(/Larg)", "CoP_unload_ML(/Larg)")

vitesse_cop_vars <- c("Vpic_load_AP(m/s)", "Vpic_load_ML(m/s)", "Vpic_unload_ML(m/s)")

bos_com_vars <- c("BOS_AP_Init(m)", "BOS_ML_Init(m)", "MOS_AP_FOcr(/Long)", "MOS_ML_FOcr(/Larg)")

anthropo_vars <- c("Weight", "Height", "Epaule", "Coude", "Poignet", "Main")
# V√©rifier que les colonnes existent dans la base de donn√©es
vars_to_check <- c(time_vars, cop_vars, vitesse_cop_vars, bos_com_vars, anthropo_vars)
vars_to_check <- vars_to_check[vars_to_check %in% colnames(donnees)]

# Convertir les colonnes en num√©rique en √©vitant les erreurs
donnees[vars_to_check] <- lapply(donnees[vars_to_check], function(x) as.numeric(as.character(x)))

# D√©tection des valeurs aberrantes avec la m√©thode IQR
detect_outliers <- function(x) {
  x <- na.omit(x)  # Retirer les valeurs manquantes
  Q1 <- quantile(x, 0.25, na.rm = TRUE)
  Q3 <- quantile(x, 0.75, na.rm = TRUE)
  IQR <- Q3 - Q1
  lower_bound <- Q1 - 1.5 * IQR
  upper_bound <- Q3 + 1.5 * IQR
  return(x[x < lower_bound | x > upper_bound])  # Retourner les valeurs aberrantes plut√¥t que leurs indices
}

# Appliquer la fonction √† chaque groupe de variables
outliers_time <- lapply(donnees[time_vars], detect_outliers)
outliers_cop <- lapply(donnees[cop_vars], detect_outliers)
outliers_vitesse_cop <- lapply(donnees[vitesse_cop_vars], detect_outliers)
outliers_bos_com <- lapply(donnees[bos_com_vars], detect_outliers)
outliers_anthropo <- lapply(donnees[anthropo_vars], detect_outliers)

# Afficher les indices des valeurs aberrantes pour chaque groupe de variables
outliers_time
outliers_cop
outliers_vitesse_cop
outliers_bos_com
outliers_anthropo

```

### Visualisation des valeurs aberrantes avec des boxplots
```{r}
# Charger ggplot2 pour la visualisation
library(ggplot2)
library(reshape2)

# Fusionner les donn√©es en format long pour ggplot
df_long_time <- melt(donnees, id.vars = c("Sujet"), measure.vars = time_vars)
df_long_cop <- melt(donnees, id.vars = c("Sujet"), measure.vars = cop_vars)
df_long_vitesse_cop <- melt(donnees, id.vars = c("Sujet"), measure.vars = vitesse_cop_vars)
df_long_bos_com <- melt(donnees, id.vars = c("Sujet"), measure.vars = bos_com_vars)
df_long_anthropo <- melt(donnees, id.vars = c("Sujet"), measure.vars = anthropo_vars)

# Tracer les boxplots pour chaque groupe de variables

ggplot(df_long_time) + 
  aes(x = variable, y = value) + 
  geom_boxplot(outlier.colour = "red", outlier.shape = 8, fill = "lightblue") + 
  labs(title = "Boxplots des variables temporelles", x = "Variables", y = "Valeurs") + 
  theme_minimal()

ggplot(df_long_cop) + 
  aes(x = variable, y = value) + 
  geom_boxplot(outlier.colour = "red", outlier.shape = 8, fill = "lightblue") + 
  labs(title = "Boxplots des variables du CoP", x = "Variables", y = "Valeurs") + 
  theme_minimal()

ggplot(df_long_vitesse_cop) + 
  aes(x = variable, y = value) + 
  geom_boxplot(outlier.colour = "red", outlier.shape = 8, fill = "lightblue") + 
  labs(title = "Boxplots des variables de vitesse du CoP", x = "Variables", y = "Valeurs") + 
  theme_minimal()

ggplot(df_long_bos_com) + 
  aes(x = variable, y = value) + 
  geom_boxplot(outlier.colour = "red", outlier.shape = 8, fill = "lightblue") + 
  labs(title = "Boxplots des variables de BoS et CoM", x = "Variables", y = "Valeurs") + 
  theme_minimal()

ggplot(df_long_anthropo) + 
  aes(x = variable, y = value) + 
  geom_boxplot(outlier.colour = "red", outlier.shape = 8, fill = "lightblue") + 
  labs(title = "Boxplots des variables anthropom√©triques", x = "Variables", y = "Valeurs") + 
  theme_minimal()

```

### Correction des valeurs aberrantes (remplacement par la m√©diane)
```{r}
# Correction des valeurs aberrantes (remplacement par la m√©diane)
correct_outliers <- function(data, vars) {
  for (col in vars) {
    Q1 <- quantile(data[[col]], 0.25, na.rm = TRUE)
    Q3 <- quantile(data[[col]], 0.75, na.rm = TRUE)
    IQR <- Q3 - Q1
    lower_bound <- Q1 - 1.5 * IQR
    upper_bound <- Q3 + 1.5 * IQR
    
    data[[col]] <- ifelse(data[[col]] < lower_bound | data[[col]] > upper_bound, 
                          median(data[[col]], na.rm = TRUE), data[[col]])
  }
  return(data)
}

# Appliquer la correction aux diff√©rents groupes de variables
donnees <- correct_outliers(donnees, time_vars)
donnees <- correct_outliers(donnees, cop_vars)
donnees <- correct_outliers(donnees, vitesse_cop_vars)
donnees <- correct_outliers(donnees, bos_com_vars)
donnees <- correct_outliers(donnees, anthropo_vars)

```

### Visualisation apr√®s correction
```{r}
# Conversion des donn√©es en format long apr√®s correction
df_long_time_corrected <- melt(donnees, id.vars = c("Sujet"), measure.vars = time_vars)
df_long_cop_corrected <- melt(donnees, id.vars = c("Sujet"), measure.vars = cop_vars)
df_long_vitesse_cop_corrected <- melt(donnees, id.vars = c("Sujet"), measure.vars = vitesse_cop_vars)
df_long_bos_com_corrected <- melt(donnees, id.vars = c("Sujet"), measure.vars = bos_com_vars)
df_long_anthropo_corrected <- melt(donnees, id.vars = c("Sujet"), measure.vars = anthropo_vars)

ggplot(df_long_time_corrected) + 
  aes(x = variable, y = value) + 
  geom_boxplot(outlier.colour = "red", outlier.shape = 8, fill = "lightgreen") + 
  labs(title = "Boxplots des variables temporelles apr√®s correction", x = "Variables", y = "Valeurs") + 
  theme_minimal()

# Tracer les boxplots apr√®s correction
ggplot(df_long_cop_corrected) + 
  aes(x = variable, y = value) + 
  geom_boxplot(outlier.colour = "red", outlier.shape = 8, fill = "lightgreen") + 
  labs(title = "Boxplots des variables du CoP apr√®s correction", x = "Variables", y = "Valeurs") + 
  theme_minimal()

ggplot(df_long_vitesse_cop_corrected) + 
  aes(x = variable, y = value) + 
  geom_boxplot(outlier.colour = "red", outlier.shape = 8, fill = "lightgreen") + 
  labs(title = "Boxplots des variables de vitesse du CoP apr√®s correction", x = "Variables", y = "Valeurs") + 
  theme_minimal()

ggplot(df_long_bos_com_corrected) + 
  aes(x = variable, y = value) + 
  geom_boxplot(outlier.colour = "red", outlier.shape = 8, fill = "lightgreen") + 
  labs(title = "Boxplots des variables de BoS et CoM apr√®s correction", x = "Variables", y = "Valeurs") + 
  theme_minimal()

ggplot(df_long_anthropo_corrected) + 
  aes(x = variable, y = value) + 
  geom_boxplot(outlier.colour = "red", outlier.shape = 8, fill = "lightgreen") + 
  labs(title = "Boxplots des variables anthropom√©triques apr√®s correction", x = "Variables", y = "Valeurs") + 
  theme_minimal()

```

## Q2.3

```{r}
# Charger les biblioth√®ques n√©cessaires
library(dplyr)
library(tidyr)

# S√©lection des variables pertinentes
selected_vars <- c(time_vars, cop_vars, vitesse_cop_vars, bos_com_vars, anthropo_vars)


# Fonction pour calculer les statistiques descriptives
desc_stats <- donnees %>%
  select(all_of(selected_vars)) %>%
  summarise_all(list(
    Moyenne = mean,
    M√©diane = median,
    Variance = var,
    Ecart_Type = sd
  ), na.rm = TRUE)

# Afficher les r√©sultats sous forme de tableau
print(desc_stats)

```


### Histogrammes pour observer la distribution des variables temporelles
```{r}
# Transformer les donn√©es en format long
library(tidyr)

donnees_long <- donnees %>%
  pivot_longer(cols = all_of(time_vars), names_to = "Variable", values_to = "Valeur")

# Tracer tous les histogrammes avec facet_wrap
ggplot(donnees_long, aes(x = Valeur)) +
  geom_histogram(binwidth = 10, fill = "blue", color = "black", alpha = 0.7) +
  facet_wrap(~Variable, scales = "free") +
  labs(title = "Distribution des variables temporelles", x = "Valeurs", y = "Fr√©quence") +
  theme_minimal()



```


###  Analyse des distributions avec des densit√©s
```{r}

# Densit√©s des variables temporelles
donnees_long <- donnees %>%
  select(all_of(time_vars)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Valeur")

ggplot(donnees_long)+
  aes(x = Valeur, fill = Variable) +
  geom_density(alpha = 0.5) +
  labs(title = "Densit√© des variables temporelles", x = "Valeurs", y = "Densit√©") +
  theme_minimal()

```

### Effectifs et statistiques anthropom√©triques
```{r}
library(kableExtra)
# Cr√©ation d'une variable pour les groupes d'√¢ge
donnees <- donnees %>%
  mutate(Groupe_Age = ifelse(Age <= 8, "6-8 ans", "9-11 ans"))

# Moyennes des variables temporelles par groupe d'√¢ge
age_means <- donnees %>%
  group_by(Groupe_Age) %>%
  summarise(across(all_of(time_vars), mean, na.rm = TRUE))

# Affichage format√© du tableau
kable(age_means, caption = "Comparaison des performances selon l‚Äô√¢ge") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```


```{r}
# Cr√©ation du tableau des effectifs et des statistiques sur la taille et le poids
stats_anthropo <- donnees %>%
  group_by(Groupe_Age) %>%
  summarise(
    Effectif = n(),
    Poids_Moyen = mean(Weight, na.rm = TRUE),
    Taille_Moyenne = mean(Height, na.rm = TRUE),
    Poids_M√©diane = median(Weight, na.rm = TRUE),
    Taille_M√©diane = median(Height, na.rm = TRUE)
  )

# Affichage format√© du tableau
kable(stats_anthropo, caption = "Effectifs et caract√©ristiques anthropom√©triques par groupe d‚Äô√¢ge") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE) %>%
  row_spec(0, bold = TRUE, background = "#4CAF50", color = "white") %>%  # Couleur de l'ent√™te
  row_spec(1, background = "#f2f2f2") %>%  # Premi√®re ligne color√©e en gris clair
  row_spec(2, background = "#ffffff")  # Seconde ligne en blanc pour alterner

```


```{r}
ggplot(donnees, aes(x = Weight, fill = Groupe_Age)) +
  geom_histogram(position = "identity", alpha = 0.5, bins = 10) +
  labs(title = "Distribution du poids par groupe d'√¢ge", x = "Poids (kg)", y = "Fr√©quence") +
  theme_minimal()

```

```{r}
# Transformation des donn√©es en format long pour ggplot
donnees_long_cop <- donnees %>%
  select(all_of(cop_vars)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Valeur")

# Tracer les histogrammes avec facet_wrap
ggplot(donnees_long_cop, aes(x = Valeur, fill = Variable)) +
  geom_histogram(binwidth = 0.05, color = "black", alpha = 0.6) +
  facet_wrap(~Variable, scales = "free") +
  labs(title = "Distribution des variables li√©es au CoP", x = "Valeurs", y = "Fr√©quence") +
  theme_minimal()
```





## 3. Effet de l‚Äô√¢ge

## Q3.1

### V√©rification des conditions pour le test statistique
```{r}
# Charger les biblioth√®ques n√©cessaires
library(dplyr)
library(ggplot2)
library(car)

# D√©finition des variables d'anticipation
anticipation_vars <- c("TAju(ms)", "TExe(ms)", "TPas(ms)", "TLoad(ms)", "TUnload(ms)",
                       "CoP_tot_AP(/Long)", "CoP_tot_ML(/Larg)", "CoP_load_AP(/Long)", 
                       "CoP_load_ML(/Larg)", "CoP_unload_AP(/Long)", "CoP_unload_ML(/Larg)",
                       "Vpic_load_AP(m/s)", "Vpic_load_ML(m/s)", "Vpic_unload_AP(m/s)", 
                       "Vpic_unload_ML(m/s)", "BOS_AP_init(m)", "BOS_ML_init(m)", 
                       "MOS_AP_F0cr(Long)", "MOS_ML_F0cr(Larg)")

# V√©rification des variables pr√©sentes
anticipation_vars <- intersect(anticipation_vars, colnames(donnees))

# Cr√©ation des groupes d'√¢ge
donnees <- donnees %>%
  mutate(Groupe_Age = ifelse(Age <= 8, "6-8 ans", "9-11 ans"))

# V√©rification des conditions pour chaque variable d'anticipation
results <- list()

for (var in anticipation_vars) {
  # Test de normalit√© (Shapiro-Wilk)
  shapiro_6_8 <- shapiro.test(donnees %>% filter(Groupe_Age == "6-8 ans") %>% pull(var))
  shapiro_9_11 <- shapiro.test(donnees %>% filter(Groupe_Age == "9-11 ans") %>% pull(var))
  
  # Test d'homog√©n√©it√© des variances (Levene)
  levene <- leveneTest(donnees[[var]], donnees$Groupe_Age)
  
  # Stockage des r√©sultats
  results[[var]] <- list(
    Shapiro_6_8 = shapiro_6_8$p.value,
    Shapiro_9_11 = shapiro_9_11$p.value,
    Levene = levene$`Pr(>F)`[1]
  )
}

# Affichage des r√©sultats
print(results)

```

### Application des tests
‚úÖ Si Shapiro-Wilk est non significatif (p > 0.05) ‚Üí On peut supposer une normalit√©
‚úÖ Si Levene est non significatif (p > 0.05) ‚Üí Les variances sont homog√®nes
Si les donn√©es sont normales et homog√®nes ‚Üí On applique le test t de Student.
Sinon ‚Üí On applique le test de Mann-Whitney.

```{r}
# Initialisation d'une liste pour stocker les r√©sultats des tests
test_results <- list()

# Parcourir chaque variable d'anticipation
for (var in anticipation_vars) {
  # V√©rification des conditions pour choisir le test
  if (results[[var]]$Shapiro_6_8 > 0.05 & results[[var]]$Shapiro_9_11 > 0.05) {
    if (results[[var]]$Levene > 0.05) {
      # Test t de Student (variances homog√®nes)
      test_result <- t.test(donnees %>% filter(Groupe_Age == "6-8 ans") %>% pull(var),
                            donnees %>% filter(Groupe_Age == "9-11 ans") %>% pull(var),
                            var.equal = TRUE)
    } else {
      # Test t de Student (variances h√©t√©rog√®nes)
      test_result <- t.test(donnees %>% filter(Groupe_Age == "6-8 ans") %>% pull(var),
                            donnees %>% filter(Groupe_Age == "9-11 ans") %>% pull(var),
                            var.equal = FALSE)
    }
  } else {
    # Test de Mann-Whitney (si normalit√© non respect√©e)
    test_result <- wilcox.test(donnees %>% filter(Groupe_Age == "6-8 ans") %>% pull(var),
                               donnees %>% filter(Groupe_Age == "9-11 ans") %>% pull(var))
  }
  
  # Stocker les r√©sultats
  test_results[[var]] <- test_result
}

# Afficher les r√©sultats des tests
print(test_results)

```

### Visualisation avec des boxplots
```{r}
# Transformation des donn√©es en format long
library(reshape2)

donnees_long <- melt(donnees, id.vars = "Groupe_Age", measure.vars = anticipation_vars)

# Tracer les boxplots
ggplot(donnees_long, aes(x = Groupe_Age, y = value, fill = Groupe_Age)) +
  geom_boxplot(alpha = 0.7, outlier.colour = "red") +
  facet_wrap(~variable, scales = "free") +
  labs(title = "Comparaison des variables d'anticipation selon l'√¢ge",
       x = "Groupe d'√¢ge", y = "Valeurs") +
  theme_minimal()

```



```{r}
# Cr√©ation d'un tableau des statistiques par groupe d'√¢ge
stats_anticipation <- donnees %>%
  group_by(Groupe_Age) %>%
  summarise(across(all_of(anticipation_vars), list(
    Moyenne = mean,
    M√©diane = median
  ), na.rm = TRUE))

# Affichage du tableau
library(kableExtra)
kable(stats_anticipation, caption = "Moyennes et m√©dianes des variables d'anticipation par groupe d'√¢ge") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```

### Tableau des r√©sultats des tests statistiques
```{r}
# Cr√©ation d'un dataframe pour stocker les r√©sultats
test_summary <- tibble(
  Variable = anticipation_vars,
  Test_utilis√© = sapply(anticipation_vars, function(var) {
    if (results[[var]]$Shapiro_6_8 > 0.05 & results[[var]]$Shapiro_9_11 > 0.05) {
      if (results[[var]]$Levene > 0.05) "Test t de Student (var √©gal)" else "Test t de Student (var in√©gal)"
    } else {
      "Test de Mann-Whitney"
    }
  }),
  p_value = sapply(anticipation_vars, function(var) test_results[[var]]$p.value),
  Significatif = sapply(anticipation_vars, function(var) ifelse(test_results[[var]]$p.value < 0.05, "Oui", "Non"))
)

# Affichage du tableau avec formatage
library(kableExtra)
kable(test_summary, caption = "R√©sultats des tests statistiques") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```


```{r}
# Calcul des moyennes par groupe
moyennes_par_groupe <- donnees %>%
  group_by(Groupe_Age) %>%
  summarise(across(all_of(anticipation_vars), mean, na.rm = TRUE), .groups = "drop")

# Transformation en format long
moyennes_par_groupe_long <- moyennes_par_groupe %>%
  pivot_longer(cols = -Groupe_Age, names_to = "Variable", values_to = "Moyenne")

# Fusion avec les r√©sultats des tests
test_summary <- left_join(test_summary, moyennes_par_groupe_long, by = "Variable")

# Affichage du tableau avec formatage
library(kableExtra)
kable(test_summary, caption = "R√©sultats des tests statistiques et moyennes par groupe") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```


## Q3.2
### Cr√©ation des groupes d'√¢ge
```{r}
donnees <- donnees %>%
  mutate(Groupe_Age3 = case_when(
    Age < 8 ~ "6-7 ans",
    Age >= 8 & Age < 10 ~ "8-9 ans",
    Age >= 10 & Age < 12 ~ "10-11 ans"
  ))
# V√©rification de la r√©partition des groupes d'√¢ge
print(table(donnees$Groupe_Age3))


```

### Test de normalit√© (Shapiro-Wilk)
Nous allons appliquer le test de Shapiro-Wilk pour v√©rifier si les donn√©es suivent une distribution normale pour chaque variable et groupe d'√¢ge.
```{r}
# Initialiser une liste pour stocker les p-values des tests de normalit√©
normality_tests <- list()

for (var in anticipation_vars) {
  normality_tests[[var]] <- donnees %>%
    group_by(Groupe_Age3) %>%
    summarise(p_value = shapiro.test(get(var))$p.value, .groups = "drop")
}

# Convertir en DataFrame
normality_results <- bind_rows(lapply(names(normality_tests), function(v) {
  df <- normality_tests[[v]]
  df$Variable <- v
  return(df)
}))

# Affichage des r√©sultats
print(normality_results)

```




### Test d‚Äôhomog√©n√©it√© des variances (Levene)
Nous allons tester l‚Äô√©galit√© des variances avec le test de Levene.
```{r}
homogeneity_tests <- lapply(anticipation_vars, function(var) {
  leveneTest(as.formula(paste0("`", var, "` ~ Groupe_Age3")), data = donnees)
})


# Convertir en DataFrame
homogeneity_results <- tibble(
  Variable = anticipation_vars,
  p_value = sapply(homogeneity_tests, function(test) test$`Pr(>F)`[1])
)

# Affichage des r√©sultats
print(homogeneity_results)

```


### S√©lection et application du test statistique

Nous allons maintenant choisir entre l‚ÄôANOVA et le test de Kruskal-Wallis en fonction des r√©sultats des tests de normalit√© et d‚Äôhomog√©n√©it√© des variances.
```{r}
# üìå Initialisation des listes de r√©sultats
anova_results <- list()
kruskal_results <- list()

# üìå Boucle pour chaque variable d'anticipation
for (var in anticipation_vars) {
  
  # R√©cup√©ration des p-values des tests de normalit√© et d'homog√©n√©it√©
  normal_pvalues <- normality_results %>% filter(Variable == var) %>% pull(p_value)
  homogeneity_pvalue <- homogeneity_results %>% filter(Variable == var) %>% pull(p_value)

  # üìå V√©rification que les valeurs existent et ne sont pas NA
  if (length(normal_pvalues) == 0 || length(homogeneity_pvalue) == 0 || 
      any(is.na(normal_pvalues)) || is.na(homogeneity_pvalue)) {
    print(paste("‚ö† Valeur manquante pour la variable :", var, "‚Üí Test ignor√©"))
    next  # Passer √† la variable suivante
  }

  # üìå S√©lection du test en fonction des conditions
  if (all(normal_pvalues > 0.05, na.rm = TRUE) && homogeneity_pvalue > 0.05) {
    anova_results[[var]] <- aov(as.formula(paste0("`", var, "` ~ Groupe_Age3")), data = donnees)
  } else {
    kruskal_results[[var]] <- kruskal.test(as.formula(paste0("`", var, "` ~ Groupe_Age3")), data = donnees)
  }
}

# üìå Affichage des r√©sultats
print(anova_results)
print(kruskal_results)
```


### Pr√©sentation des r√©sultats sous forme de tableau
Nous allons maintenant regrouper tous les r√©sultats dans un tableau et afficher les p-values ainsi que l‚Äôinterpr√©tation de la significativit√©.
```{r}
test_summary <- tibble(
  Variable = anticipation_vars,
  Test_utilis√© = sapply(anticipation_vars, function(var) {
    if (!is.null(anova_results[[var]])) "ANOVA" else "Kruskal-Wallis"
  }),
  p_value = sapply(anticipation_vars, function(var) {
    if (!is.null(anova_results[[var]])) summary(anova_results[[var]])[[1]][["Pr(>F)"]][1]
    else kruskal_results[[var]]$p.value
  }),
  Significatif = sapply(anticipation_vars, function(var) {
    ifelse(!is.null(anova_results[[var]]) && summary(anova_results[[var]])[[1]][["Pr(>F)"]][1] < 0.05, "Oui",
           ifelse(!is.null(kruskal_results[[var]]) && kruskal_results[[var]]$p.value < 0.05, "Oui", "Non"))
  })
)

# Affichage format√© du tableau
library(kableExtra)
kable(test_summary, caption = "R√©sultats des tests statistiques pour comparer les trois groupes d'√¢ge") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```


### Visualisation des r√©sultats avec des boxplots
```{r}
library(ggplot2)
library(reshape2)

donnees_long <- melt(donnees, id.vars = "Groupe_Age3", measure.vars = anticipation_vars)

ggplot(donnees_long, aes(x = Groupe_Age3, y = value, fill = Groupe_Age3)) +
  geom_boxplot(alpha = 0.7, outlier.colour = "red") +
  facet_wrap(~variable, scales = "free") +
  labs(title = "Comparaison des variables d'anticipation selon l'√¢ge",
       x = "Groupe d'√¢ge", y = "Valeurs") +
  theme_minimal()

```


## Q3.3

### M√©thode alternative : R√©gression Lin√©aire32
Pourquoi une r√©gression lin√©aire ?
‚úÖ Pr√©cision accrue : On √©vite la perte d‚Äôinformation caus√©e par la cat√©gorisation de l‚Äô√¢ge.
‚úÖ Analyse plus fine : On peut tester directement l'effet de l'√¢ge sur chaque variable.
‚úÖ Visualisation des tendances : On peut examiner les relations lin√©aires entre l‚Äô√¢ge et les variables mesur√©es.
Nous allons ajuster un mod√®le de r√©gression lin√©aire pour chaque variable d'anticipation en consid√©rant l‚Äô√¢ge comme pr√©dicteur.
```{r}
# üìå V√©rification des noms des variables
anticipation_vars <- anticipation_vars[anticipation_vars %in% colnames(donnees)]

# üìå Initialisation d'une liste pour stocker les r√©sultats
regression_results <- list()

# üìä Mod√®le lin√©aire pour chaque variable
for (var in anticipation_vars) {
  # V√©rifier que la variable existe
  if (!(var %in% colnames(donnees))) {
    print(paste("Variable manquante :", var))
    next  # Passer √† la variable suivante
  }
  
  # Utilisation des backticks pour g√©rer les noms avec caract√®res sp√©ciaux
  model <- lm(as.formula(paste0("`", var, "` ~ Age")), data = donnees)
  regression_results[[var]] <- model  # Stocker l'objet mod√®le, pas summary(model)
}

# üìå Extraction des r√©sultats sous forme de tableau
regression_summary <- tibble(
  Variable = anticipation_vars,
  Coefficient_Age = sapply(regression_results, function(m) coef(m)[2]),  # Coefficient de Age
  p_value = sapply(regression_results, function(m) summary(m)$coefficients[2,4])  # p-value du test
)

# üìä Affichage des r√©sultats sous forme de tableau
library(kableExtra)
kable(regression_summary, caption = "R√©sultats de la r√©gression lin√©aire entre l'√¢ge et les variables d'anticipation") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```




### Visualisation avec des Graphiques
```{r}
# Transformer les donn√©es en format long
library(reshape2)
donnees_long <- melt(donnees, id.vars = "Age", measure.vars = anticipation_vars, 
                     variable.name = "Variable", value.name = "Valeur")

# Tracer les graphiques de r√©gression
library(ggplot2)
ggplot(donnees_long, aes(x = Age, y = Valeur)) +
  geom_point(alpha = 0.5) +  # Points des observations
  geom_smooth(method = "lm", col = "blue") +  # R√©gression lin√©aire
  facet_wrap(~Variable, scales = "free") +  # S√©parer les graphiques par variable
  labs(title = "Effet de l'√¢ge sur les variables d'anticipation",
       x = "√Çge (ann√©es)", y = "Valeur mesur√©e") +
  theme_minimal()


```



## Q3.4
√âvaluer l‚Äôeffet de l‚Äô√¢ge sur la taille et le poids
Pour r√©pondre √† cette question, nous allons effectuer plusieurs analyses :

    Analyse de la corr√©lation entre √¢ge, taille et poids üìä
    R√©gression lin√©aire simple : √âvaluer l‚Äôeffet de l‚Äô√¢ge sur la taille et le poids s√©par√©ment.
    R√©gression lin√©aire multiple : V√©rifier si l‚Äôeffet de l‚Äô√¢ge persiste apr√®s ajustement pour la taille et le poids

### Analyse de la corr√©lation entre l‚Äô√¢ge, la taille et le poids
Avant de r√©aliser une r√©gression, nous devons explorer les relations entre ces variables en calculant des coefficients de corr√©lation.
```{r}
#install.packages("ggcorrplot")
# Calcul des corr√©lations
cor_matrix <- donnees %>% 
  select(Age, Height, Weight) %>% 
  cor(use = "complete.obs")

# Affichage de la matrice de corr√©lation
library(ggcorrplot)
ggcorrplot(cor_matrix, lab = TRUE, method = "circle", type = "lower", 
           title = "Corr√©lation entre l'√¢ge, la taille et le poids")

```



### R√©gression lin√©aire simple : Effet de l‚Äô√¢ge sur la taille et le poids
Nous allons r√©aliser deux mod√®les de r√©gression pour voir si l'√¢ge influence significativement la taille et le poids.
```{r}
# R√©gression de la taille en fonction de l'√¢ge
modele_taille <- lm(Height ~ Age, data = donnees)
summary(modele_taille)

# R√©gression du poids en fonction de l'√¢ge
modele_poids <- lm(Weight ~ Age, data = donnees)
summary(modele_poids)

```

### R√©gression lin√©aire multiple : Contr√¥ler les effets confondants
```{r}
# R√©gression de la taille en fonction de l'√¢ge et du poids
modele_taille_multi <- lm(Height ~ Age + Weight, data = donnees)
summary(modele_taille_multi)

# R√©gression du poids en fonction de l'√¢ge et de la taille
modele_poids_multi <- lm(Weight ~ Age + Height, data = donnees)
summary(modele_poids_multi)

```


